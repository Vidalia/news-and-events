import AekStorage from "-aek/storage";
import Request from "-aek/request";

class CampusLocator {

  /**
    Constructs a Campus object by initializing a LocalStorage object
  */
  constructor() {
    this.storage = new AekStorage("uoe");
    this.error = null;

    this.getRegisteredCampus();

    // TODO: Either find a better place of storing this or fetch it from a webservice?
    // Conveniently, this also mirrors the mapping in ISS.Campus (0 => Colchester, 1 => Southend etc...)
    this.campus = [
      {
        name: "Colchester",
        short: "CO",

        location: {
          latitude: 51.877235,
          longitude: 0.947487
        }
      },

      {
        name: "Southend",
        short: "SO",

        location: {
          latitude: 51.538192,
          longitude: 0.712006
        }
      },

      {
        name: "Loughton",
        short: "LO",

        location: {
          latitude: 51.649579,
          longitude: 0.077210
        }
      }
    ];
  }

  /**
    Returns a promise which, when resolved, returns an object containing the user's
    current campus. Otherwise returns an Error describing what went wrong
  */
  getCampus() {

    var promise = new Promise((resolve, reject) => {

      var location = this.getDeviceLocation();

      // Try and get a campus from geolocation
      location.then((result) => {
        var closest = this.getClosestCampus(result.latitude, result.longitude);
        resolve(closest);
      },
      // If that fails, try and fetch campus from webservice
      // TODO: Campus location webservice
      (error) => {
        reject(error);
      });

    });

    return promise;
  }

  /**
    Fetches the campus that the student is currently registered at.
  */
  getRegisteredCampus(force = false) {
    var promise = new Promise((resolve) => {

      var storedCampus = this.storage.get("registered-campus");

      // If the current campus is stored in cache, make sure it's fresh
      // and resolve the promise.
      if(storedCampus) {
        var now = Math.floor(Date.now() / 1000),
            then = storedCampus.timestamp;

            // Refresh the stored campus every fortnight
            if(((now - then) / 60 * 24) > 14) {
              force = true;
            }
      }

      // If we don't have to refresh the campus, resolve the promise
      if(storedCampus && !force) {
        resolve(storedCampus.campus);
      } else {

        // Request.action will send a POST request to the current page.
        // This request is then handled by the INIT block in main.ect
        Request.action("studentRecord")

        .end((error, response) => {
          // If there wasn't an error AND the response object has either a
          //  CurrentYearModules or NextYearModules property...
          if(!error && (
            response.body && (
              typeof response.body.currentYearModules !== typeof undefined ||
              typeof response.body.nextYearModules !== typeof undefined)
            )
          ) {

            var campus = this._defaultCampus(response.body);
            this.storage.set("registered-campus", { campus: campus, timestamp: Math.floor(Date.now() / 1000) });
            resolve(campus);

          } else {
            // If we can't fetch the registered campus from web service, try and
            // return the old cached value which is _probably_ still valid
            // otherwise return the first known campus (colchester);
            resolve(storedCampus || this.campus[0]);
          }
        });
      }

    });

    return promise;
  }

  /**
    Makes an informed guess at the users default campus by seeing which campus appears
      in currentYearModules the most
    TODO: Ideally, the student record endpoint should return this as a property
  */
  _defaultCampus(userDetails) {

    // Fetches the list of enrolled modules from either the current year or next
    // year, if not available
    var modules = ((userDetails.currentYearModules.length > 0) ? userDetails.currentYearModules : userDetails.nextYearModules).module;

    // Campuses found and the number of times they appear
    var campuses = [];

    // The current campus which has appeared the most
    var maxCount = 0,
        maxCampus = this.campus[0];

    for(var i = 0; i < modules.length; i++) {

      var module = modules[i];

      // Increment the campus counter
      var count = campuses[module.campus] || 0;
      count = count + 1;

      // If the current campus appears more, set that as the current winner
      if(count > maxCount) {
        maxCount = count;
        maxCampus = this.campus.filter((campus) => { return campus.name === module.campus; });
      }
    }

    return maxCampus;
  }

  /**
    Fetches information about the current user
    TODO: There's an -aek/personal-details module which doesn't seem to work. Are we doing something wrong?
  */
  getCurrentUser() {
    var data = JSON.parse(localStorage['cache_/campusm/sso/state']).data;

    // Actual username has a non-obvious key in local storage
    data.username = data.serviceUsername_363;

    return data;
  }

  /**
    Fetches the users current physical location, either from cache if still fresh, or
    from the geolocation service

    @param force boolean  If true, forces a location refresh
  */
  getDeviceLocation(force = false) {

    var promise = new Promise((resolve, reject) => {

      // Check if the location is currently in the cache
      var location = this.storage.get("location");

      // If the cached location isn't fresh, force an update
      if(location) {
        var now = Math.floor(Date.now() / 1000),
            then = location.timestamp;

        // Force a refresh every two hours
        if(((now - then) / 60) > 2 ) {
          force = true;
        }
      }

      // If there's a location in the cache and we're not forcing a refresh, we're done
      if(location && !force) {
        console.debug("Resolved location from cache", location);
        resolve(location);
      } else {
        // Otherwise we're fetching a new location
        var navigator = window.navigator;

        // First have to make sure that geolocation is actually set up
        if(navigator.geolocation) {
          navigator.geolocation.getCurrentPosition((position) => {

            var location = {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              timestamp: Math.floor(Date.now() / 1000) // Current timestamp in seconds
            };

            this.storage.set("location", location);
            console.debug("Resolved location from Geo", location);
            resolve(location);

          }, (error) => {
            this.storage.set("location", null);
            console.warn("Could not resolve location from geo");
            reject(error);
          });
        } else {
          console.error("HTML5 geolocation not supported");
          reject(new Error("Geolocation is not supported"));
        }
      }
    });

    return promise;

  }


  /**
    Finds the closest campus to the current location
    If no campus is within ten miles, default to Colchester
    TODO: Webservice call to fetch campus from students' course?
  */
  getClosestCampus(latitude, longitude) {

    // Iterate through each of the campuses available, and see which is closes
    var closest = this.campus[0],
        distance = 11; // distance in miles (ish)

    this.campus.forEach((campus) => {
      var campusLat = campus.location.latitude,
          campusLon = campus.location.longitude;

      var distanceToThis = this.distance(campusLat, campusLon, latitude, longitude);
      if(distanceToThis < distance) {
        distance = distanceToThis;
        closest = campus;
      }
    });

    return closest;
  }

  /**
    Calculates the distance between two lat/long coordinates in Miles
    Thank god for stackoverflow
  */
  distance(lat1, lon1, lat2, lon2) {
    var radLat1 = Math.PI * lat1 / 180,
        radLat2 = Math.PI * lat2 / 180;

    var theta = lon1 - lon2,
        radTheta = Math.PI * theta / 180;

    var dist = Math.sin(radLat1) * Math.sin(radLat2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.cos(radTheta);
    dist = Math.acos(dist);
    dist = dist * 180 / Math.PI;
    dist = dist * 60 * 1.1515;
    return dist;
  }

}

module.exports = CampusLocator;
